@using MudBlazor
@using SmashScheduler.Domain.Entities
@using SmashScheduler.Web.Components
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudStack Spacing="4">
    <CourtDisplay Matches="@ActiveMatches"
                  CourtCount="@Session.CourtCount"
                  CourtLabels="@Session.CourtLabels"
                  PlayerLookup="@PlayerLookup"
                  IsReadOnly="false"
                  OnMatchComplete="@OnMatchComplete"
                  OnMatchEdit="@HandleEditMatch"
                  OnCreateMatch="@HandleCreateMatch" />

    <BenchDisplay BenchedPlayers="@GetBenchedPlayers()" GamesPlayedLookup="@GamesPlayedLookup" />
</MudStack>

@if (CanGenerateMatches)
{
    <MudFab Class="@($"{GetFabClass()} smash-fab-fixed")"
            StartIcon="@(IsGenerating ? Icons.Material.Filled.Sync : Icons.Material.Filled.AutoAwesome)"
            Label="@(IsGenerating ? "Generating..." : "Generate Matches")"
            OnClick="HandleGenerateMatches"
            Disabled="@IsGenerating"
            Size="Size.Large" />
}

@code {
    [Parameter, EditorRequired] public Session Session { get; set; } = null!;
    [Parameter] public List<Match> ActiveMatches { get; set; } = new();
    [Parameter] public Dictionary<Guid, Player> PlayerLookup { get; set; } = new();
    [Parameter] public EventCallback OnGenerateMatches { get; set; }
    [Parameter] public EventCallback<Guid> OnMatchComplete { get; set; }
    [Parameter] public EventCallback<(Guid MatchId, List<Guid> PlayerIds)> OnMatchPlayersUpdate { get; set; }
    [Parameter] public EventCallback<(int CourtNumber, List<Guid> PlayerIds)> OnMatchCreate { get; set; }
    [Parameter] public EventCallback<int> OnAutoGenerateSingleMatch { get; set; }
    [Parameter] public bool CanGenerateMatches { get; set; }
    [Parameter] public Dictionary<Guid, int> GamesPlayedLookup { get; set; } = new();

    private bool IsGenerating { get; set; }

    private string GetFabClass()
    {
        return IsGenerating ? "smash-fab smash-fab--loading" : "smash-fab";
    }

    private IEnumerable<Player> GetBenchedPlayers()
    {
        var playingPlayerIds = ActiveMatches
            .Where(m => m.State == Domain.Enums.MatchState.InProgress)
            .SelectMany(m => m.PlayerIds)
            .ToHashSet();

        return Session.SessionPlayers
            .Where(sp => sp.IsActive)
            .Select(sp => sp.PlayerId)
            .Where(id => !playingPlayerIds.Contains(id) && PlayerLookup.ContainsKey(id))
            .Select(id => PlayerLookup[id]);
    }

    private async Task HandleGenerateMatches()
    {
        IsGenerating = true;
        StateHasChanged();

        await OnGenerateMatches.InvokeAsync();

        IsGenerating = false;
        StateHasChanged();
    }

    private async Task HandleEditMatch(Guid matchId)
    {
        var match = ActiveMatches.FirstOrDefault(m => m.Id == matchId);
        if (match == null) return;

        var playersInOtherMatches = ActiveMatches
            .Where(m => m.Id != matchId && m.State == Domain.Enums.MatchState.InProgress)
            .SelectMany(m => m.PlayerIds)
            .ToHashSet();

        var benchPlayerIds = GetBenchedPlayers().Select(p => p.Id).ToList();

        var parameters = new DialogParameters<MatchEditorDialog>
        {
            { x => x.Match, match },
            { x => x.PlayerLookup, PlayerLookup },
            { x => x.BenchPlayerIds, benchPlayerIds },
            { x => x.PlayersInOtherMatches, playersInOtherMatches }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<MatchEditorDialog>("Edit Match Players", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: List<Guid> newPlayerIds })
        {
            await OnMatchPlayersUpdate.InvokeAsync((matchId, newPlayerIds));
        }
    }

    private async Task HandleCreateMatch(int courtNumber)
    {
        var benchPlayerIds = GetBenchedPlayers().Select(p => p.Id).ToList();

        if (benchPlayerIds.Count < 4)
        {
            Snackbar.Add("Not enough players on bench (need at least 4)", Severity.Warning);
            return;
        }

        if (OnAutoGenerateSingleMatch.HasDelegate)
        {
            await OnAutoGenerateSingleMatch.InvokeAsync(courtNumber);
            var courtLabel = Session.GetCourtLabel(courtNumber);
            Snackbar.Add($"Match generated for {courtLabel}", Severity.Success);
        }
        else
        {
            await ShowManualMatchDialog(courtNumber, benchPlayerIds);
        }
    }

    private async Task ShowManualMatchDialog(int courtNumber, List<Guid> benchPlayerIds)
    {
        var parameters = new DialogParameters<ManualMatchDialog>
        {
            { x => x.CourtNumber, courtNumber },
            { x => x.PlayerLookup, PlayerLookup },
            { x => x.BenchPlayerIds, benchPlayerIds }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<ManualMatchDialog>("Create Manual Match", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: List<Guid> playerIds })
        {
            await OnMatchCreate.InvokeAsync((courtNumber, playerIds));
        }
    }
}
