"use client";

import { useState, useEffect, useMemo } from "react";
import { useRouter } from "next/navigation";
import { createClient } from "@/lib/supabase/client";
import {
  getDb,
  seedSession,
  seedSessionPlayers,
  seedCourtLabels,
  seedMatches,
  seedMatchPlayers,
} from "@/lib/db/index";
import { enqueueMutation, processQueue } from "@/lib/db/sync";
import { useSyncStatus } from "@/hooks/use-sync-status";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ManualMatchDialog } from "@/components/manual-match-dialog";
import { CompleteMatchDialog } from "@/components/complete-match-dialog";
import { AutoGenerateDialog } from "@/components/auto-generate-dialog";
import { AutoDraftDialog } from "@/components/auto-draft-dialog";
import { MatchPreviewDialog } from "@/components/match-preview-dialog";
import { AddPlayerDialog } from "@/components/add-player-dialog";
import {
  type AlgorithmPlayer,
  type CompletedMatchRecord,
  type MatchCandidate,
  type ScoringWeights,
  type MatchConfig,
  generateMatches,
} from "@/lib/matchmaking";
import {
  BarChart2,
  Armchair,
  Plus,
  ChevronUp,
  ChevronDown,
  ChevronsUpDown,
  Check,
  Activity,
  Wifi,
  WifiOff,
  Loader2,
  Play,
  UserX,
  UserCheck,
  UserPlus,
  ClipboardList,
  Trash2,
} from "lucide-react";

// ─── Types ────────────────────────────────────────────────────────────────────

type Player = {
  id: string;
  name: string | null;
  gender: number;
  numerical_skill_level: number | null;
  skill_tier_id: string | null;
  play_style_preference: number;
};

type SessionPlayer = {
  player_id: string;
  is_active: boolean;
  player?: Player;
};

type MatchPlayer = {
  player_id: string;
  team_number: number;
};

type Match = {
  id: string;
  court_number: number;
  state: number; // 0=inProgress, 1=completed, 2=draft
  was_automated: boolean;
  started_at: string | null;
  completed_at: string | null;
  team1_score: number | null;
  team2_score: number | null;
  winning_team: number | null;
  players: MatchPlayer[];
};

type CourtLabel = {
  court_number: number;
  label: string;
};

type Session = {
  id: string;
  scheduled_date_time: string;
  court_count: number;
  state: number;
};

type SortField = "name" | "games" | "time";
type SortDir = "asc" | "desc";

const genderColours: Record<number, string> = {
  0: "var(--smash-gender-male)",
  1: "var(--smash-gender-female)",
};

// ─── Props ────────────────────────────────────────────────────────────────────

type MatchmakingProfile = {
  id: string;
  name: string;
  weight_skill_balance: number;
  weight_time_off_court: number;
  weight_match_history: number;
  apply_gender_matching: boolean;
  gender_matching_mode: number; // 0=preferred (soft), 1=strict (hard)
  blacklist_mode: number;
};

type SkillTier = {
  id: string;
  name: string;
  score: number;
};

type Props = {
  sessionId: string;
  clubSlug: string;
  clubId: string;
  gameType: number; // 0=singles, 1=doubles
  skillType: number; // 0=numerical, 1=tier
  skillTiers: SkillTier[];
  session: Session;
  sessionPlayers: SessionPlayer[];
  courtLabels: CourtLabel[];
  matches: Match[];
  matchmakingProfiles: MatchmakingProfile[];
  defaultProfileId: string | null;
  playerBlacklists: Array<{
    player_id: string;
    blacklisted_player_id: string;
    blacklist_type: number; // 0=opponent, 1=partner
  }>;
};

// ─── Component ────────────────────────────────────────────────────────────────

export function ActiveSessionClient({
  sessionId,
  clubSlug,
  clubId,
  gameType,
  skillType,
  skillTiers,
  session,
  sessionPlayers,
  courtLabels,
  matches: initialMatches,
  matchmakingProfiles,
  defaultProfileId,
  playerBlacklists,
}: Props) {
  const router = useRouter();
  const supabase = createClient();
  const { isOnline, pendingCount, isSyncing } = useSyncStatus();

  // ─── Local state ──────────────────────────────────────────────────────────

  const [isEnding, setIsEnding] = useState(false);
  const [sessionEnded, setSessionEnded] = useState(false);
  const [localSessionPlayers, setLocalSessionPlayers] =
    useState<SessionPlayer[]>(sessionPlayers);
  const [localMatches, setLocalMatches] = useState<Match[]>(initialMatches);
  const [sortField, setSortField] = useState<SortField>("name");
  const [sortDir, setSortDir] = useState<SortDir>("asc");

  // Dialog state
  const [matchDialogOpen, setMatchDialogOpen] = useState(false);
  const [matchDialogMode, setMatchDialogMode] = useState<"manual" | "draft">(
    "manual"
  );
  const [completeDialogMatch, setCompleteDialogMatch] = useState<Match | null>(
    null
  );
  const [autoGenerateOpen, setAutoGenerateOpen] = useState(false);
  const [autoDraftOpen, setAutoDraftOpen] = useState(false);
  const [addPlayerOpen, setAddPlayerOpen] = useState(false);
  const [matchPreviewOpen, setMatchPreviewOpen] = useState(false);
  const [previewData, setPreviewData] = useState<{
    proposals: MatchCandidate[];
    weights: ScoringWeights;
    courts: number[];
    config: MatchConfig;
    isDraft: boolean;
  } | null>(null);

  // ─── Seed IDB on mount ────────────────────────────────────────────────────

  useEffect(() => {
    seedSession({
      id: session.id,
      club_id: "",
      scheduled_date_time: session.scheduled_date_time,
      court_count: session.court_count,
      state: session.state,
    });
    seedSessionPlayers(
      sessionId,
      sessionPlayers.map((sp) => ({
        player_id: sp.player_id,
        is_active: sp.is_active,
      }))
    );
    seedCourtLabels(sessionId, courtLabels);

    const matchValues = initialMatches.map((m) => ({
      id: m.id,
      session_id: sessionId,
      court_number: m.court_number,
      state: m.state,
      was_automated: m.was_automated,
      started_at: m.started_at,
      completed_at: m.completed_at,
      team1_score: m.team1_score,
      team2_score: m.team2_score,
      winning_team: m.winning_team,
    }));
    seedMatches(matchValues);

    const matchPlayerValues = initialMatches.flatMap((m) =>
      m.players.map((mp) => ({
        match_id: m.id,
        player_id: mp.player_id,
        team_number: mp.team_number,
      }))
    );
    seedMatchPlayers(matchPlayerValues);
  }, [session, sessionId, sessionPlayers, courtLabels, initialMatches]);

  // ─── Navigate after offline session end ───────────────────────────────────

  useEffect(() => {
    if (sessionEnded && isOnline && pendingCount === 0) {
      router.push(`/clubs/${clubSlug}/sessions`);
      router.refresh();
    }
  }, [sessionEnded, isOnline, pendingCount, clubSlug, router]);

  // ─── Derived values ───────────────────────────────────────────────────────

  const playersPerMatch = gameType === 0 ? 2 : 4;
  const courtCount = session.court_count;
  const courts = Array.from({ length: courtCount }, (_, i) => i + 1);

  const scheduledDate = new Date(session.scheduled_date_time);

  const activePlayers = localSessionPlayers.filter(
    (sp) => sp.is_active && sp.player
  );
  const sittingOutPlayers = localSessionPlayers.filter(
    (sp) => !sp.is_active && sp.player
  );

  const committedPlayerIds = useMemo(() => {
    return new Set(
      localMatches
        .filter((m) => m.state === 0 || m.state === 2)
        .flatMap((m) => m.players.map((mp) => mp.player_id))
    );
  }, [localMatches]);

  const benchPlayers = activePlayers.filter(
    (sp) => !committedPlayerIds.has(sp.player_id)
  );

  const usedCourts = new Set(
    localMatches.filter((m) => m.state === 0).map((m) => m.court_number)
  );
  const availableCourts = courts.filter((n) => !usedCourts.has(n));
  const draftMatches = localMatches.filter((m) => m.state === 2);

  const nInProgress = localMatches.filter((m) => m.state === 0).length;
  const nCompleted = localMatches.filter((m) => m.state === 1).length;
  const completedMatches = localMatches.filter((m) => m.state === 1);

  // Player stats (games played + last match time)
  const playerStatsMap = useMemo(() => {
    const map = new Map<
      string,
      { gamesPlayed: number; lastCompletedAt: number }
    >();
    for (const sp of localSessionPlayers) {
      const playerCompleted = completedMatches.filter((m) =>
        m.players.some((mp) => mp.player_id === sp.player_id)
      );
      const lastCompletedAt =
        playerCompleted.length > 0
          ? Math.max(
              ...playerCompleted.map((m) =>
                m.completed_at ? new Date(m.completed_at).getTime() : 0
              )
            )
          : 0;
      map.set(sp.player_id, {
        gamesPlayed: playerCompleted.length,
        lastCompletedAt,
      });
    }
    return map;
  }, [localSessionPlayers, completedMatches]);

  const avgGamesPerPlayer =
    activePlayers.length > 0
      ? (
          Array.from(playerStatsMap.values()).reduce(
            (sum, s) => sum + s.gamesPlayed,
            0
          ) / activePlayers.length
        ).toFixed(1)
      : "0";

  const completedWithDuration = completedMatches.filter(
    (m) => m.started_at && m.completed_at
  );
  const avgMatchMins =
    completedWithDuration.length > 0
      ? Math.round(
          completedWithDuration.reduce((sum, m) => {
            const start = new Date(m.started_at!).getTime();
            const end = new Date(m.completed_at!).getTime();
            return sum + (end - start) / 60000;
          }, 0) / completedWithDuration.length
        )
      : null;

  // ─── Algorithm data ───────────────────────────────────────────────────────

  const tierScoreMap = useMemo(() => {
    const m = new Map<string, number>();
    for (const t of skillTiers) m.set(t.id, t.score);
    return m;
  }, [skillTiers]);

  const tierNameMap = useMemo(() => {
    const m = new Map<string, string>();
    for (const t of skillTiers) m.set(t.id, t.name);
    return m;
  }, [skillTiers]);

  const blacklistMap = useMemo(() => {
    const m = new Map<string, { opponentIds: string[]; partnerIds: string[] }>();
    for (const bl of playerBlacklists) {
      if (!m.has(bl.player_id)) {
        m.set(bl.player_id, { opponentIds: [], partnerIds: [] });
      }
      const entry = m.get(bl.player_id)!;
      if (bl.blacklist_type === 0) {
        entry.opponentIds.push(bl.blacklisted_player_id);
      } else {
        entry.partnerIds.push(bl.blacklisted_player_id);
      }
    }
    return m;
  }, [playerBlacklists]);

  const algorithmBenchPlayers = useMemo<AlgorithmPlayer[]>(() => {
    return benchPlayers
      .filter((sp) => sp.player)
      .map((sp) => {
        let skillLevel: number;
        if (skillType === 0) {
          skillLevel = sp.player!.numerical_skill_level ?? 5;
        } else {
          const score =
            sp.player!.skill_tier_id != null
              ? (tierScoreMap.get(sp.player!.skill_tier_id) ?? 50)
              : 50;
          skillLevel = Math.max(1, Math.min(10, Math.round(score / 10)));
        }
        const bl = blacklistMap.get(sp.player_id);
        return {
          id: sp.player_id,
          name: sp.player!.name ?? "Unknown",
          gender: sp.player!.gender,
          skillLevel,
          playStylePreference: sp.player!.play_style_preference,
          opponentBlacklist: bl?.opponentIds ?? [],
          partnerBlacklist: bl?.partnerIds ?? [],
        };
      });
  }, [benchPlayers, skillType, tierScoreMap, blacklistMap]);

  const algorithmCompletedMatches = useMemo<CompletedMatchRecord[]>(() => {
    return localMatches
      .filter((m) => m.state === 1)
      .map((m) => ({
        playerIds: m.players.map((mp) => mp.player_id),
        completedAt: m.completed_at,
      }));
  }, [localMatches]);

  const playerInfoMap = useMemo(() => {
    const m = new Map<string, { name: string; gender: number; skillText: string }>();
    for (const sp of localSessionPlayers) {
      if (!sp.player) continue;
      let skillText: string;
      if (skillType === 0) {
        skillText =
          sp.player.numerical_skill_level != null
            ? sp.player.numerical_skill_level.toString()
            : "?";
      } else {
        skillText = sp.player.skill_tier_id
          ? (tierNameMap.get(sp.player.skill_tier_id) ?? "?")
          : "?";
      }
      m.set(sp.player_id, {
        name: sp.player.name ?? "Unknown",
        gender: sp.player.gender,
        skillText,
      });
    }
    return m;
  }, [localSessionPlayers, skillType, tierNameMap]);

  // ─── Helpers ─────────────────────────────────────────────────────────────

  function getCourtName(num: number): string {
    return (
      courtLabels.find((cl) => cl.court_number === num)?.label ?? `Court ${num}`
    );
  }

  function getPlayer(playerId: string): Player | undefined {
    return localSessionPlayers.find((sp) => sp.player_id === playerId)?.player;
  }

  function getPlayerName(playerId: string): string {
    return getPlayer(playerId)?.name ?? "Unknown";
  }

  function getPlayerLocation(playerId: string): string {
    const inProgress = localMatches.find(
      (m) =>
        m.state === 0 && m.players.some((mp) => mp.player_id === playerId)
    );
    if (inProgress) return getCourtName(inProgress.court_number);

    const inDraft = localMatches.find(
      (m) =>
        m.state === 2 && m.players.some((mp) => mp.player_id === playerId)
    );
    if (inDraft) return "Draft";

    const sp = localSessionPlayers.find((s) => s.player_id === playerId);
    if (!sp?.is_active) return "Sitting Out";

    return "Bench";
  }

  function formatLastMatch(lastCompletedAt: number): string {
    if (lastCompletedAt === 0) return "N/A";
    const mins = Math.floor((Date.now() - lastCompletedAt) / 60000);
    if (mins < 1) return "Just now";
    if (mins === 1) return "1 min ago";
    return `${mins} min ago`;
  }

  function handleSort(field: SortField) {
    if (sortField === field) {
      setSortDir((d) => (d === "asc" ? "desc" : "asc"));
    } else {
      setSortField(field);
      setSortDir("asc");
    }
  }

  const sortedStatsPlayers = useMemo(() => {
    return [...localSessionPlayers.filter((sp) => sp.player)].sort((a, b) => {
      const dir = sortDir === "asc" ? 1 : -1;
      if (sortField === "name") {
        return (
          (a.player?.name ?? "").localeCompare(b.player?.name ?? "") * dir
        );
      }
      if (sortField === "games") {
        const ag = playerStatsMap.get(a.player_id)?.gamesPlayed ?? 0;
        const bg = playerStatsMap.get(b.player_id)?.gamesPlayed ?? 0;
        return (ag - bg) * dir;
      }
      if (sortField === "time") {
        const at = playerStatsMap.get(a.player_id)?.lastCompletedAt ?? 0;
        const bt = playerStatsMap.get(b.player_id)?.lastCompletedAt ?? 0;
        return (at - bt) * dir;
      }
      return 0;
    });
  }, [localSessionPlayers, sortField, sortDir, playerStatsMap]);

  // ─── Match operations (offline-first) ────────────────────────────────────

  async function handleCreateMatch(
    players: { player_id: string; team_number: number }[],
    courtNumber: number,
    wasAutomated = false
  ) {
    const matchId = crypto.randomUUID();
    const now = new Date().toISOString();
    const isDraft = courtNumber === 0;

    const newMatch: Match = {
      id: matchId,
      court_number: courtNumber,
      state: isDraft ? 2 : 0,
      was_automated: wasAutomated,
      started_at: isDraft ? null : now,
      completed_at: null,
      team1_score: null,
      team2_score: null,
      winning_team: null,
      players,
    };

    setLocalMatches((prev) => [...prev, newMatch]);

    try {
      const db = await getDb();
      await db.put("matches", {
        id: matchId,
        session_id: sessionId,
        court_number: courtNumber,
        state: newMatch.state,
        was_automated: false,
        started_at: newMatch.started_at,
        completed_at: null,
        team1_score: null,
        team2_score: null,
        winning_team: null,
      });
      for (const mp of players) {
        await db.put("match_players", {
          match_id: matchId,
          player_id: mp.player_id,
          team_number: mp.team_number,
        });
      }

      await enqueueMutation("matches", "insert", {
        id: matchId,
        session_id: sessionId,
        court_number: courtNumber,
        state: newMatch.state,
        was_automated: wasAutomated,
        started_at: newMatch.started_at,
      });
      for (const mp of players) {
        await enqueueMutation("match_players", "insert", {
          match_id: matchId,
          player_id: mp.player_id,
          team_number: mp.team_number,
        });
      }

      processQueue(supabase).catch(() => {});
    } catch {
      // IDB/sync failure is non-fatal — local state already updated
    }
  }

  async function handleCompleteMatch(
    matchId: string,
    winningTeam: number | null,
    team1Score: number | null,
    team2Score: number | null
  ) {
    const now = new Date().toISOString();

    setLocalMatches((prev) =>
      prev.map((m) =>
        m.id === matchId
          ? {
              ...m,
              state: 1,
              completed_at: now,
              winning_team: winningTeam,
              team1_score: team1Score,
              team2_score: team2Score,
            }
          : m
      )
    );

    try {
      const db = await getDb();
      const existing = await db.get("matches", matchId);
      if (existing) {
        await db.put("matches", {
          ...existing,
          state: 1,
          completed_at: now,
          winning_team: winningTeam,
          team1_score: team1Score,
          team2_score: team2Score,
        });
      }

      await enqueueMutation(
        "matches",
        "update",
        {
          state: 1,
          completed_at: now,
          winning_team: winningTeam,
          team1_score: team1Score,
          team2_score: team2Score,
        },
        { id: matchId }
      );

      processQueue(supabase).catch(() => {});
    } catch {
      // non-fatal
    }
  }

  async function handleStartDraft(matchId: string, courtNumber: number) {
    const now = new Date().toISOString();

    setLocalMatches((prev) =>
      prev.map((m) =>
        m.id === matchId
          ? { ...m, state: 0, court_number: courtNumber, started_at: now }
          : m
      )
    );

    try {
      const db = await getDb();
      const existing = await db.get("matches", matchId);
      if (existing) {
        await db.put("matches", {
          ...existing,
          state: 0,
          court_number: courtNumber,
          started_at: now,
        });
      }

      await enqueueMutation(
        "matches",
        "update",
        { state: 0, court_number: courtNumber, started_at: now },
        { id: matchId }
      );

      processQueue(supabase).catch(() => {});
    } catch {
      // non-fatal
    }
  }

  async function handleToggleActive(playerId: string) {
    const sp = localSessionPlayers.find((s) => s.player_id === playerId);
    if (!sp) return;
    const newIsActive = !sp.is_active;

    setLocalSessionPlayers((prev) =>
      prev.map((s) =>
        s.player_id === playerId ? { ...s, is_active: newIsActive } : s
      )
    );

    try {
      const db = await getDb();
      await db.put("session_players", {
        session_id: sessionId,
        player_id: playerId,
        is_active: newIsActive,
      });

      await enqueueMutation(
        "session_players",
        "update",
        { is_active: newIsActive },
        { session_id: sessionId, player_id: playerId }
      );

      processQueue(supabase).catch(() => {});
    } catch {
      // non-fatal
    }
  }

  async function handleEndSession() {
    setIsEnding(true);
    try {
      await enqueueMutation(
        "sessions",
        "update",
        { state: 2 },
        { id: sessionId }
      );

      if (isOnline) {
        await processQueue(supabase);
        router.push(`/clubs/${clubSlug}/sessions`);
        router.refresh();
      } else {
        setSessionEnded(true);
        setIsEnding(false);
      }
    } catch {
      setIsEnding(false);
    }
  }

  async function handleDeleteDraft(matchId: string) {
    const match = localMatches.find((m) => m.id === matchId);
    if (!match) return;

    setLocalMatches((prev) => prev.filter((m) => m.id !== matchId));

    try {
      const db = await getDb();
      for (const mp of match.players) {
        await db.delete("match_players", [matchId, mp.player_id]);
      }
      await db.delete("matches", matchId);

      // DB cascade removes match_players; just delete the match
      await enqueueMutation("matches", "delete", undefined, { id: matchId });

      processQueue(supabase).catch(() => {});
    } catch {
      // non-fatal
    }
  }

  async function handleAddPlayer(player: {
    id: string;
    name: string;
    gender: number;
    numerical_skill_level: number | null;
    skill_tier_id: string | null;
    play_style_preference: number;
  }) {
    const newSp: SessionPlayer = {
      player_id: player.id,
      is_active: true,
      player,
    };

    setLocalSessionPlayers((prev) => [...prev, newSp]);

    try {
      const db = await getDb();
      await db.put("session_players", {
        session_id: sessionId,
        player_id: player.id,
        is_active: true,
      });

      await enqueueMutation("session_players", "insert", {
        session_id: sessionId,
        player_id: player.id,
        is_active: true,
      });

      processQueue(supabase).catch(() => {});
    } catch {
      // non-fatal
    }
  }

  async function handleConfirmProposals(
    matches: Array<{
      courtNumber: number;
      players: { player_id: string; team_number: number }[];
    }>
  ) {
    setMatchPreviewOpen(false);
    for (const match of matches) {
      await handleCreateMatch(match.players, match.courtNumber, true);
    }
  }

  async function handleConfirmDraftProposals(
    matches: Array<{
      courtNumber: number;
      players: { player_id: string; team_number: number }[];
    }>
  ) {
    setMatchPreviewOpen(false);
    for (const match of matches) {
      await handleCreateMatch(match.players, 0, true); // 0 = draft (no court)
    }
  }

  // ─── Sub-components ───────────────────────────────────────────────────────

  function SortIcon({ field }: { field: SortField }) {
    if (sortField !== field)
      return <ChevronsUpDown className="inline h-3 w-3 ml-1 opacity-40" />;
    return sortDir === "asc" ? (
      <ChevronUp className="inline h-3 w-3 ml-1" />
    ) : (
      <ChevronDown className="inline h-3 w-3 ml-1" />
    );
  }

  function SyncIndicator() {
    if (isSyncing) {
      return (
        <span className="flex items-center gap-1.5 text-xs text-muted-foreground">
          <Loader2 className="h-3 w-3 animate-spin" />
          Syncing…
        </span>
      );
    }
    if (!isOnline || pendingCount > 0) {
      return (
        <span className="flex items-center gap-1.5 text-xs text-amber-500">
          <WifiOff className="h-3 w-3" />
          {pendingCount > 0 ? `${pendingCount} unsynced` : "Offline"}
        </span>
      );
    }
    return (
      <span className="flex items-center gap-1.5 text-xs text-green-500">
        <Wifi className="h-3 w-3" />
        Synced
      </span>
    );
  }

  // ─── Offline ended screen ─────────────────────────────────────────────────

  if (sessionEnded) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[60vh] gap-4 p-6 text-center">
        <Check className="h-12 w-12 text-green-500" />
        <h2 className="text-2xl font-bold">Session Ended</h2>
        <p className="text-muted-foreground max-w-sm">
          The session has been marked as complete locally. It will sync to the
          server automatically once your connection is restored.
        </p>
        <div className="flex items-center gap-2 text-sm text-amber-500">
          <WifiOff className="h-4 w-4" />
          Waiting for connection…
        </div>
      </div>
    );
  }

  // ─── Render ───────────────────────────────────────────────────────────────

  return (
    <div className="space-y-6 p-6">
      {/* ── Header ─────────────────────────────────────────────────────────── */}
      <div className="flex flex-wrap items-start justify-between gap-4">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Active Session</h1>
          <p className="text-muted-foreground text-sm mt-1">
            {scheduledDate.toLocaleDateString("en-GB", {
              day: "numeric",
              month: "short",
              year: "numeric",
            })}{" "}
            {scheduledDate.toLocaleTimeString("en-GB", {
              hour: "2-digit",
              minute: "2-digit",
            })}{" "}
            • {courtCount} {courtCount === 1 ? "court" : "courts"}
          </p>
        </div>
        <div className="flex items-center gap-3 flex-wrap">
          <SyncIndicator />
          <Badge className="bg-green-500 hover:bg-green-500 text-white px-3 py-1 text-sm">
            LIVE
          </Badge>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm">
                <Plus className="mr-1 h-4 w-4" />
                Add Match
                <ChevronDown className="ml-1 h-3 w-3" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem
                disabled={
                  availableCourts.length === 0 ||
                  benchPlayers.length < playersPerMatch ||
                  matchmakingProfiles.length === 0
                }
                onClick={() => setAutoGenerateOpen(true)}
              >
                Auto Generate
              </DropdownMenuItem>
              <DropdownMenuItem
                disabled={
                  availableCourts.length === 0 ||
                  benchPlayers.length < playersPerMatch
                }
                onClick={() => {
                  setMatchDialogMode("manual");
                  setMatchDialogOpen(true);
                }}
              >
                Add Manual
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem
                disabled={
                  benchPlayers.length < playersPerMatch ||
                  matchmakingProfiles.length === 0
                }
                onClick={() => setAutoDraftOpen(true)}
              >
                Auto Draft
              </DropdownMenuItem>
              <DropdownMenuItem
                disabled={benchPlayers.length < playersPerMatch}
                onClick={() => {
                  setMatchDialogMode("draft");
                  setMatchDialogOpen(true);
                }}
              >
                Manual Draft
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                className="border-destructive text-destructive hover:bg-destructive hover:text-destructive-foreground"
                disabled={isEnding}
              >
                End Session
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>End Session?</AlertDialogTitle>
                <AlertDialogDescription>
                  {isOnline
                    ? "Are you sure you want to end this session? This will mark it as complete."
                    : "You are currently offline. The session will be marked complete locally and synced when your connection returns."}
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handleEndSession}
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                >
                  End Session
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </div>
      </div>

      {/* ── Session Statistics ──────────────────────────────────────────────── */}
      <Accordion type="single" collapsible>
        <AccordionItem value="stats" className="border rounded-lg px-4">
          <AccordionTrigger className="hover:no-underline py-4">
            <div className="flex items-center gap-3">
              <BarChart2 className="h-5 w-5 text-muted-foreground shrink-0" />
              <span className="font-semibold">Session Statistics</span>
              <Badge variant="secondary" className="text-xs font-normal">
                {nInProgress} playing • {nCompleted} completed
              </Badge>
            </div>
          </AccordionTrigger>
          <AccordionContent>
            <div className="space-y-4 pb-4">
              <div className="grid grid-cols-2 lg:grid-cols-4 gap-3">
                <div className="rounded-lg bg-green-500/15 p-4">
                  <p className="text-2xl font-bold text-green-600 dark:text-green-400">
                    {nInProgress}
                  </p>
                  <p className="text-sm text-muted-foreground">In Progress</p>
                </div>
                <div className="rounded-lg bg-green-500/15 p-4">
                  <p className="text-2xl font-bold text-green-600 dark:text-green-400">
                    {nCompleted}
                  </p>
                  <p className="text-sm text-muted-foreground">Completed</p>
                </div>
                <div className="rounded-lg bg-blue-500/15 p-4">
                  <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">
                    {avgGamesPerPlayer}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    Avg Games/Player
                  </p>
                </div>
                <div className="rounded-lg bg-blue-500/15 p-4">
                  <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">
                    {avgMatchMins !== null ? `${avgMatchMins}m` : "N/A"}
                  </p>
                  <p className="text-sm text-muted-foreground">
                    Avg Match Duration
                  </p>
                </div>
              </div>

              <div>
                <h3 className="font-semibold mb-2 text-sm">
                  Player Statistics
                </h3>
                <div className="rounded-md border overflow-hidden">
                  <div className="max-h-60 overflow-y-auto">
                    <table className="w-full text-sm">
                      <thead className="sticky top-0 bg-muted/80 backdrop-blur">
                        <tr>
                          <th
                            className="text-left p-2 px-3 font-medium cursor-pointer select-none"
                            onClick={() => handleSort("name")}
                          >
                            Player <SortIcon field="name" />
                          </th>
                          <th
                            className="text-center p-2 px-3 font-medium cursor-pointer select-none"
                            onClick={() => handleSort("games")}
                          >
                            Games <SortIcon field="games" />
                          </th>
                          <th
                            className="text-center p-2 px-3 font-medium cursor-pointer select-none"
                            onClick={() => handleSort("time")}
                          >
                            Last Game <SortIcon field="time" />
                          </th>
                          <th className="text-center p-2 px-3 font-medium">
                            Where
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {sortedStatsPlayers.map((sp) => {
                          const stats = playerStatsMap.get(sp.player_id);
                          return (
                            <tr key={sp.player_id} className="border-t">
                              <td className="p-2 px-3">
                                <div className="flex items-center gap-2">
                                  <span
                                    className="h-3 w-3 rounded-full shrink-0"
                                    style={{
                                      backgroundColor:
                                        genderColours[sp.player?.gender ?? 2],
                                    }}
                                  />
                                  <span
                                    className={
                                      sp.is_active
                                        ? ""
                                        : "text-muted-foreground"
                                    }
                                  >
                                    {sp.player?.name ?? "Unknown"}
                                  </span>
                                  {!sp.is_active && (
                                    <Badge
                                      variant="outline"
                                      className="text-[10px] px-1 py-0"
                                    >
                                      Out
                                    </Badge>
                                  )}
                                </div>
                              </td>
                              <td className="p-2 px-3 text-center text-muted-foreground">
                                {stats?.gamesPlayed ?? 0}
                              </td>
                              <td className="p-2 px-3 text-center text-muted-foreground">
                                {formatLastMatch(stats?.lastCompletedAt ?? 0)}
                              </td>
                              <td className="p-2 px-3 text-center text-muted-foreground text-xs">
                                {getPlayerLocation(sp.player_id)}
                              </td>
                            </tr>
                          );
                        })}
                        {sortedStatsPlayers.length === 0 && (
                          <tr>
                            <td
                              colSpan={4}
                              className="p-4 text-center text-muted-foreground"
                            >
                              No players in session
                            </td>
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>

      {/* ── Courts ─────────────────────────────────────────────────────────── */}
      <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
        {courts.map((courtNum) => {
          const match = localMatches.find(
            (m) => m.state === 0 && m.court_number === courtNum
          );
          const courtName = getCourtName(courtNum);

          if (match) {
            const team1 = match.players.filter((mp) => mp.team_number === 1);
            const team2 = match.players.filter((mp) => mp.team_number === 2);
            return (
              <div
                key={courtNum}
                className="rounded-lg border-2 border-green-600/40 bg-green-600/5 p-4 space-y-3"
              >
                <div className="flex items-center justify-between">
                  <p className="font-semibold text-sm text-green-400">
                    {courtName}
                  </p>
                  <Badge className="bg-green-700/80 hover:bg-green-700/80 text-white gap-1 text-xs">
                    <Activity className="h-3 w-3" />
                    Playing
                  </Badge>
                </div>

                <div className="space-y-2 text-sm">
                  <div>
                    <p className="text-[10px] uppercase tracking-wide text-muted-foreground mb-1">
                      Team 1
                    </p>
                    {team1.map((mp) => {
                      const p = getPlayer(mp.player_id);
                      return (
                        <div
                          key={mp.player_id}
                          className="flex items-center gap-1.5"
                        >
                          <span
                            className="h-2 w-2 rounded-full shrink-0"
                            style={{
                              backgroundColor:
                                genderColours[p?.gender ?? 2],
                            }}
                          />
                          <span>{p?.name ?? "Unknown"}</span>
                        </div>
                      );
                    })}
                  </div>
                  <div className="text-center text-xs font-bold text-muted-foreground">
                    vs
                  </div>
                  <div>
                    <p className="text-[10px] uppercase tracking-wide text-muted-foreground mb-1">
                      Team 2
                    </p>
                    {team2.map((mp) => {
                      const p = getPlayer(mp.player_id);
                      return (
                        <div
                          key={mp.player_id}
                          className="flex items-center gap-1.5"
                        >
                          <span
                            className="h-2 w-2 rounded-full shrink-0"
                            style={{
                              backgroundColor:
                                genderColours[p?.gender ?? 2],
                            }}
                          />
                          <span>{p?.name ?? "Unknown"}</span>
                        </div>
                      );
                    })}
                  </div>
                </div>

                <div className="flex gap-1">
                  <Button
                    size="sm"
                    variant="outline"
                    className="flex-1 text-xs px-1"
                    onClick={() => handleCompleteMatch(match.id, 1, null, null)}
                  >
                    T1 Won
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    className="flex-1 text-xs px-1"
                    onClick={() => handleCompleteMatch(match.id, null, null, null)}
                  >
                    Draw
                  </Button>
                  <Button
                    size="sm"
                    variant="outline"
                    className="flex-1 text-xs px-1"
                    onClick={() => handleCompleteMatch(match.id, 2, null, null)}
                  >
                    T2 Won
                  </Button>
                </div>
              </div>
            );
          }

          // Empty court
          return (
            <div
              key={courtNum}
              className="flex flex-col items-center justify-center gap-3 rounded-lg border-2 border-dashed p-8"
            >
              <div className="h-16 w-16 rounded-full bg-teal-700/60 flex items-center justify-center">
                <Activity className="h-7 w-7 text-teal-300" />
              </div>
              <p className="font-semibold text-teal-400">{courtName}</p>
              <Badge className="bg-green-700/80 hover:bg-green-700/80 text-white gap-1.5">
                <Check className="h-3 w-3" />
                Available
              </Badge>
            </div>
          );
        })}
      </div>

      {/* ── Draft Matches ──────────────────────────────────────────────────── */}
      {draftMatches.length > 0 && (
        <div className="rounded-lg border p-4 space-y-3">
          <div className="flex items-center gap-2">
            <ClipboardList className="h-5 w-5 text-muted-foreground" />
            <h2 className="font-semibold">Draft Queue</h2>
            <Badge variant="secondary">{draftMatches.length}</Badge>
          </div>
          <div className="space-y-2">
            {draftMatches.map((match) => {
              const team1 = match.players.filter((mp) => mp.team_number === 1);
              const team2 = match.players.filter((mp) => mp.team_number === 2);
              return (
                <div
                  key={match.id}
                  className="flex items-center justify-between rounded-md border p-3 gap-3"
                >
                  <div className="text-sm flex-1 min-w-0">
                    <span className="font-medium">
                      {team1.map((mp) => getPlayerName(mp.player_id)).join(", ")}
                    </span>
                    <span className="text-muted-foreground mx-1">vs</span>
                    <span className="font-medium">
                      {team2.map((mp) => getPlayerName(mp.player_id)).join(", ")}
                    </span>
                  </div>
                  <div className="flex items-center gap-1 shrink-0">
                    {availableCourts.length === 0 ? (
                      <Button size="sm" variant="outline" disabled>
                        <Play className="h-3 w-3 mr-1" />
                        No Courts
                      </Button>
                    ) : availableCourts.length === 1 ? (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={() =>
                          handleStartDraft(match.id, availableCourts[0])
                        }
                      >
                        <Play className="h-3 w-3 mr-1" />
                        Start
                      </Button>
                    ) : (
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button size="sm" variant="outline">
                            <Play className="h-3 w-3 mr-1" />
                            Start
                            <ChevronDown className="h-3 w-3 ml-1" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          {availableCourts.map((court) => (
                            <DropdownMenuItem
                              key={court}
                              onClick={() => handleStartDraft(match.id, court)}
                            >
                              {getCourtName(court)}
                            </DropdownMenuItem>
                          ))}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    )}
                    <Button
                      size="sm"
                      variant="ghost"
                      className="px-2 text-destructive hover:text-destructive hover:bg-destructive/10"
                      onClick={() => handleDeleteDraft(match.id)}
                      title="Remove draft"
                    >
                      <Trash2 className="h-3 w-3" />
                    </Button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}

      {/* ── Bench ──────────────────────────────────────────────────────────── */}
      <div className="rounded-lg border p-4">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-2">
            <Armchair className="h-5 w-5 text-teal-500" />
            <h2 className="font-semibold">On Bench</h2>
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              className="h-7 text-xs"
              onClick={() => setAddPlayerOpen(true)}
            >
              <UserPlus className="h-3 w-3 mr-1" />
              Add Player
            </Button>
            <Badge className="bg-blue-600 hover:bg-blue-600 text-white">
              {benchPlayers.length} waiting
            </Badge>
          </div>
        </div>
        <div className="space-y-2">
          {benchPlayers.map((sp) => {
            const info = playerInfoMap.get(sp.player_id);
            const stats = playerStatsMap.get(sp.player_id);
            return (
              <div
                key={sp.player_id}
                className="flex items-center rounded-md border p-2"
              >
                <span
                  className="h-4 w-4 rounded-full shrink-0"
                  style={{
                    backgroundColor: genderColours[sp.player?.gender ?? 2],
                  }}
                />
                <div className="ml-2 flex-1 min-w-0">
                  <p className="font-medium">{sp.player?.name ?? "Unknown"}</p>
                  <p className="text-xs text-muted-foreground">
                    {info?.skillText ?? "?"} • {stats?.gamesPlayed ?? 0} games
                  </p>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs text-muted-foreground"
                  onClick={() => handleToggleActive(sp.player_id)}
                >
                  <UserX className="h-3 w-3 mr-1" />
                  Sit Out
                </Button>
              </div>
            );
          })}
          {benchPlayers.length === 0 && (
            <p className="text-muted-foreground text-sm">
              No players on bench
            </p>
          )}
        </div>
      </div>

      {/* ── Sitting Out ────────────────────────────────────────────────────── */}
      {sittingOutPlayers.length > 0 && (
        <div className="rounded-lg border p-4">
          <div className="flex items-center gap-2 mb-4">
            <UserX className="h-5 w-5 text-muted-foreground" />
            <h2 className="font-semibold text-muted-foreground">Sitting Out</h2>
            <Badge variant="secondary">{sittingOutPlayers.length}</Badge>
          </div>
          <div className="space-y-2">
            {sittingOutPlayers.map((sp) => (
              <div
                key={sp.player_id}
                className="flex items-center rounded-md border p-2 opacity-60"
              >
                <span
                  className="h-4 w-4 rounded-full shrink-0"
                  style={{
                    backgroundColor: genderColours[sp.player?.gender ?? 2],
                  }}
                />
                <p className="font-medium ml-2 flex-1">
                  {sp.player?.name ?? "Unknown"}
                </p>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-7 text-xs"
                  onClick={() => handleToggleActive(sp.player_id)}
                >
                  <UserCheck className="h-3 w-3 mr-1" />
                  Rejoin
                </Button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* ── Dialogs ────────────────────────────────────────────────────────── */}
      <AutoGenerateDialog
        open={autoGenerateOpen}
        onClose={() => setAutoGenerateOpen(false)}
        availableCourts={availableCourts}
        courtLabels={courtLabels}
        profiles={matchmakingProfiles}
        defaultProfileId={defaultProfileId}
        onGenerate={(selectedCourts, profileId) => {
          setAutoGenerateOpen(false);
          const profile = matchmakingProfiles.find((p) => p.id === profileId);
          if (!profile || algorithmBenchPlayers.length === 0) return;
          const weights: ScoringWeights = {
            skillBalance: profile.weight_skill_balance,
            matchHistory: profile.weight_match_history,
            timeOffCourt: profile.weight_time_off_court,
          };
          const config: MatchConfig = {
            applyGenderMatching: profile.apply_gender_matching,
            genderMatchingMode: profile.gender_matching_mode,
            blacklistMode: profile.blacklist_mode,
          };
          const proposals = generateMatches(
            algorithmBenchPlayers,
            algorithmCompletedMatches,
            selectedCourts,
            weights,
            playersPerMatch,
            config
          );
          setPreviewData({ proposals, weights, courts: selectedCourts, config, isDraft: false });
          setMatchPreviewOpen(true);
        }}
      />

      <AutoDraftDialog
        open={autoDraftOpen}
        onClose={() => setAutoDraftOpen(false)}
        maxDrafts={Math.floor(benchPlayers.length / playersPerMatch)}
        profiles={matchmakingProfiles}
        defaultProfileId={defaultProfileId}
        onGenerate={(count, profileId) => {
          setAutoDraftOpen(false);
          const profile = matchmakingProfiles.find((p) => p.id === profileId);
          if (!profile || algorithmBenchPlayers.length === 0) return;
          const weights: ScoringWeights = {
            skillBalance: profile.weight_skill_balance,
            matchHistory: profile.weight_match_history,
            timeOffCourt: profile.weight_time_off_court,
          };
          const config: MatchConfig = {
            applyGenderMatching: profile.apply_gender_matching,
            genderMatchingMode: profile.gender_matching_mode,
            blacklistMode: profile.blacklist_mode,
          };
          // Virtual court numbers 1..count — used only as internal IDs in the preview
          const virtualCourts = Array.from({ length: count }, (_, i) => i + 1);
          const proposals = generateMatches(
            algorithmBenchPlayers,
            algorithmCompletedMatches,
            virtualCourts,
            weights,
            playersPerMatch,
            config
          );
          setPreviewData({ proposals, weights, courts: virtualCourts, config, isDraft: true });
          setMatchPreviewOpen(true);
        }}
      />

      <AddPlayerDialog
        open={addPlayerOpen}
        onClose={() => setAddPlayerOpen(false)}
        clubId={clubId}
        existingPlayerIds={localSessionPlayers.map((sp) => sp.player_id)}
        skillType={skillType}
        skillTiers={skillTiers}
        onAdd={handleAddPlayer}
      />

      <ManualMatchDialog
        open={matchDialogOpen}
        onClose={() => setMatchDialogOpen(false)}
        mode={matchDialogMode}
        benchPlayers={benchPlayers}
        playersPerMatch={playersPerMatch}
        availableCourts={availableCourts}
        courtLabels={courtLabels}
        onConfirm={(players, courtNumber) => {
          setMatchDialogOpen(false);
          handleCreateMatch(players, courtNumber);
        }}
      />

      <CompleteMatchDialog
        open={completeDialogMatch !== null}
        onClose={() => setCompleteDialogMatch(null)}
        match={completeDialogMatch}
        getPlayerName={getPlayerName}
        getCourtName={getCourtName}
        onConfirm={(matchId, winningTeam, t1Score, t2Score) => {
          setCompleteDialogMatch(null);
          handleCompleteMatch(matchId, winningTeam, t1Score, t2Score);
        }}
      />

      {previewData && (
        <MatchPreviewDialog
          open={matchPreviewOpen}
          onClose={() => setMatchPreviewOpen(false)}
          initialProposals={previewData.proposals}
          allBenchPlayers={algorithmBenchPlayers}
          playerInfo={playerInfoMap}
          completedMatches={algorithmCompletedMatches}
          weights={previewData.weights}
          playersPerMatch={playersPerMatch}
          selectedCourts={previewData.courts}
          courtLabels={
            previewData.isDraft
              ? previewData.courts.map((n) => ({ court_number: n, label: `Draft ${n}` }))
              : courtLabels
          }
          config={previewData.config}
          mode={previewData.isDraft ? "draft" : "generate"}
          onManualFallback={() => {
            setMatchPreviewOpen(false);
            setMatchDialogMode(previewData.isDraft ? "draft" : "manual");
            setMatchDialogOpen(true);
          }}
          onConfirm={
            previewData.isDraft ? handleConfirmDraftProposals : handleConfirmProposals
          }
        />
      )}
    </div>
  );
}
